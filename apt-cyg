#!/bin/bash

# apt-cyg: install tool for cygwin similar to debian apt-get
#
# Copyright (C) 2005-9, Stephen Jungels
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# (http://www.fsf.org/licensing/licenses/gpl.html)

# this script requires some packages
for cmd in wget bzip2 tar awk # xz
do
  if ! which $cmd 1>/dev/null 2>/dev/null
  then
    echo You must install wget, tar, gawk bzip2 and xz to use apt-cyg.
    exit 1
  fi
done
unset cmd


function usage()
{
  echo "apt-cyg: Installs and removes Cygwin packages."
  echo "  apt-cyg install <package names>       : install packages"
  echo "  apt-cyg reinstall <package names>     : re-install packages"
  echo "  apt-cyg remove <package names>        : remove packages"
  echo "  apt-cyg mirrors                       : show mirrors"
  echo "  apt-cyg update                        : update setup.ini"
  echo "  apt-cyg show                          : show installed packages"
  echo "  apt-cyg versions                      : show installed packages versions"
  echo "  apt-cyg find <patterns>               : find packages matching patterns"
  echo "  apt-cyg search <patterns>             : (alias of find)"
  echo "  apt-cyg describe <patterns>           : describe packages matching patterns"
  echo "  apt-cyg info <patterns>               : (alias of describe)"
  echo "  apt-cyg packageof <commands or files> : locate parent packages"
  echo "Options:"
  echo "  --mirror, -m <url> : set mirror"
  echo "  --cache, -c <dir>  : set cache"
  echo "  --file, -f <file>  : read package names from file"
  echo "  --update, -u       : force update setup.ini from mirror"
  echo "  --noupdate         : don't update setup.ini from mirror (default)"
  echo "  --ignore-case, -i  : ignore case distinctions in <patterns> when finding packages"
  echo "  --match-desc, -m   : <patterns> match the package description"
  echo "  --display-format, -F <format>"
  echo "                     : specify output format for find command"
  echo "  --help"
  echo "  --version"
}

function version()
{
  echo "apt-cyg version 0.57"
  echo "Written by Stephen Jungels"
  echo ""
  echo "Copyright (c) 2005-9 Stephen Jungels.  Released under the GPL."
}

function get_arch()
{
  local arch
  case "$(uname -m)" in
    i[3456]86)
      arch=x86
    ;;
    x86_64)
      arch=x86_64
    ;;
  esac
  echo "$arch"
}

function get_mirrors()
{
  wget -qO - 'http://cygwin.com/mirrors.html' | awk \
    -e 'BEGIN { RS="<a ";FS="href=\"|\"[> ]"; inlist=0; lc=0 }' \
    -e '/name="sitelist"/ { inlist=1 }' \
    -e 'inlist && $2 ~ /^(https?|ftp):/ { print $2; lc++ }' \
    -e 'inlist && /<hr>/ { exit }' \
    -e 'END { if (!lc) exit 1 }'
  if test $? -ne 0
  then
    echo 1>&2 Cannot get mirrors
    exit 1
  fi
}

function findworkspace()
{
  # default working directory and mirror

  mirror="http://mirrors.kernel.org/sourceware/cygwin/"
  cache="/var/cache/apt-cyg"

  # work wherever setup worked last, if possible

  if test -e /etc/setup/last-cache
  then
    tmp="`head -1 /etc/setup/last-cache`"
    cache="`cygpath -au "$tmp"`"
  fi

  if test -e /etc/setup/last-mirror
  then
    mirror="`head -1 /etc/setup/last-mirror`"
  fi
  mirrordir="`echo "$mirror" | sed -e "s/:/%3a/g" -e "s:/:%2f:g"`"
  mirrordir="$mirrordir/$(get_arch)"

  echo Working directory is $cache
  echo Mirror is $mirror
  mkdir -p "$cache/$mirrordir"
  cd "$cache/$mirrordir"
}

function getsetup()
{
  local mirror="$mirror/$(get_arch)"
  if test "$noscripts" == "0" -a "$noupdate" == "0"
  then
    test -e setup.ini && mv setup.ini setup.ini-save
    wget -N $mirror/setup.bz2
    if test -e setup.bz2 && test $? -eq 0
    then
      bunzip2 setup.bz2
      mv setup setup.ini
      echo Updated setup.ini
    else
      wget -N $mirror/setup.ini
      if test -e setup.ini && test $? -eq 0
      then
        echo Updated setup.ini
      elif test -e setup.ini-save
      then
        mv setup.ini-save setup.ini
        echo Error updating setup.ini, reverting
      else
        echo Error updating setup.ini
        exit 1
      fi
    fi
  elif test ! -e setup.ini
  then
    echo -e '\nYou should run `apt-cyg update` first'
    exit 1
  fi
}

function checkpackages()
{
  if [[ ${#packages} -eq 0 ]]
  then
    echo Nothing to do, exiting
    exit 0
  fi
}

function install_package_noscripts()
{
  checkpackages >/dev/null
  findworkspace >/dev/null
  local pkg=$1

  ignore_recursive_packages=${ignore_recursive_packages}%${pkg}%

  if test "$command" != "reinstall"
  then
    local already=`grep -c "^$pkg " /etc/setup/installed.db`
    if test $already -ge 1
    then
      echo Package $pkg is already installed, skipping
      return 0
    fi
  fi
  echo ""
  echo Checking dependencies for $pkg

  # look for package and save desc file

  mkdir -p "release/$pkg"
  cat setup.ini | awk > "release/$pkg/desc" -v package="$pkg" \
    'BEGIN{RS="\n\n@ "; FS="\n"} {if ($1 == package) {desc = $0; px++}} \
     END {if (px == 1 && desc != "") print desc; else print "Package not found"}'

  local desc=`cat "release/$pkg/desc"`
  if test "-$desc-" = "-Package not found-"
  then
    echo Package $pkg not found or ambiguous name
    rm -r "release/$pkg"
    return 1
  fi
  echo Found package $pkg

  # download and unpack the bz2 file

  # pick the latest version, which comes first
  local install=`cat "release/$pkg/desc" | awk '/^install: / { print $2; exit }'`

  if test "-$install-" = "--"
  then
    echo "Could not find \"install\" in package description: obsolete package?"
    return 1
  fi

  # recursively install required packages

  echo > /tmp/awk.$$ '/^requires: / {s=gensub("(requires: )?([^ ]+) ?", "\\2 ", "g", $0); print s}'
  local requires=`cat "release/$pkg/desc" | awk -f /tmp/awk.$$`

  local warn=0
  if ! test "-$requires-" = "--"
  then
    echo Package $pkg requires the following packages, installing:
    echo $requires
    local package
    for package in $requires
    do
      if [ `echo ${ignore_recursive_packages} | grep "%${package}%"` ]
      then
        echo Package $pkg is recursive, skipping
      else
        install_package_noscripts $package
      fi
      if ! test $? = 0 ; then warn=1; fi
    done
  fi
  if ! test $warn = 0
  then
    echo "Warning: some required packages did not install, continuing"
  fi

  echo ""
  echo Installing $pkg
  checkpackages >/dev/null
  findworkspace >/dev/null

  local file=`basename $install`
  cd "release/$pkg"
  if test "$noupdate" == "0" -a -f "$file"
  then
    rm $file
  fi
  wget -nc $mirror/$install

  # check the md5
  local digest=`cat "desc" | awk '/^install: / { print $4; exit }'`
  local digactual=`md5sum $file | awk '{print $1}'`
  if ! test $digest = $digactual
  then
    echo MD5 sum did not match, exiting
    return 1
  fi

  echo "Unpacking..."
  tar xvf "$file" -C / > "/etc/setup/$pkg.lst"
  gzip -f "/etc/setup/$pkg.lst"
  cd ../..


  # update the package database

  cat /etc/setup/installed.db | awk > /tmp/awk.$$ -v pkg="$pkg" -v bz=$file \
    '{if (ins != 1 && pkg < $1) {print pkg " " bz " 0"; ins=1}; print $0} \
     END{if (ins != 1) print pkg " " bz " 0"}'
  mv /etc/setup/installed.db /etc/setup/installed.db-save
  mv /tmp/awk.$$ /etc/setup/installed.db


  echo Package $pkg installed
}

function run_postinstall_scripts()
{
  local pis script
  pis=`ls /etc/postinstall/*.sh 2>/dev/null | wc -l`
  if test $pis -gt 0 && ! test $noscripts -eq 1
  then
    echo Running postinstall scripts
    for script in /etc/postinstall/*.sh
    do
      $script
      mv $script $script.done
    done
  fi
}

function remove_package()
{
  local pkg=$1

  local already=`grep -c "^$pkg " /etc/setup/installed.db`
  if test $already = 0
  then
    echo Package $pkg is not installed, skipping
    continue
  fi

  local dontremove="cygwin coreutils gawk bzip2 xz tar wget bash"
  for req in $dontremove
  do
    if test "-$pkg-" = "-$req-"
    then
      echo apt-cyg cannot remove package $pkg, exiting
      exit 1
    fi
  done

  if ! test -e "/etc/setup/$pkg.lst.gz"
  then
    echo Package manifest missing, cannot remove $pkg.  Exiting
    exit 1
  fi
  echo Removing $pkg

  # run preremove scripts

  if test -e "/etc/preremove/$pkg.sh"
  then
    "/etc/preremove/$pkg.sh"
    rm "/etc/preremove/$pkg.sh"
  fi

  cat "/etc/setup/$pkg.lst.gz" | gzip -d | awk '/[^\/]$/ {print "rm -f \"/" $0 "\""}' | sh
  rm "/etc/setup/$pkg.lst.gz"
  rm -f /etc/postinstall/$pkg.sh.done
  cat /etc/setup/installed.db | awk > /tmp/awk.$$ -v pkg="$pkg" '{if (pkg != $1) print $0}'
  mv /etc/setup/installed.db /etc/setup/installed.db-save
  mv /tmp/awk.$$ /etc/setup/installed.db
  echo Package $pkg removed
}

function get_installed_packages()
{
  awk '/[^ ]+ [^ ]+ 0/ {print $1}' /etc/setup/installed.db
}

function get_installed_versions()
{
  # package-name package-name-1.2.3a4-5.tar.bz2 0
  awk '/[^ ]+ [^ ]+ 0/ {
         version = gensub("\\.tar\\.\\w+$", "", "", substr($2, length($1)+2));
         print $1 "=" version;
       }' /etc/setup/installed.db
}

function get_avail_packages()
{
  local query search='$1'
  IFS=$'\n' query="$*"; query="(${query//$'\n'/$')|('})"
  [[ $match_desc -ne 0 ]] && search='$0' # search by description
  cat setup.ini | awk \
    -v IGNORECASE=${nocase#0} \
    -v query="$query" \
    -v display_format="${display_format:-'%p'}\\n" \
    -v installed="$(get_installed_versions)" \
    'BEGIN {
       RS="\n\n@ "; FS="\n";
       j = split(installed, pkgs, "\n");
       for (i = 1; i <= j; ++i) {
         split(pkgs[i], p, "=");
         versions[p[1]] = p[2];
       }
       flen["c"] =  1;
       flen["C"] = 11;
       flen["d"] = 40; fext["d"] = 1;
       flen["l"] = 40; fext["l"] = 1;
       flen["o"] = 15;
       flen["p"] = 30; fext["p"] = 1;
       flen["r"] =  0; fext["r"] = 1;
       flen["s"] = 10;
       flen["v"] = 10;
       flen["V"] = 10;
     }
     function joinspace(str) { return gensub("[[:space:]]+", " ", "g", str) }
     function delquote(str) { return gensub("^\"(.*)\"$", "\\1", "", str) }
     function splitget(str, idx, sep,  ary) {
       split(str, ary, sep);
       return ary[idx];
     }
     function parsedesc(str, res,  ary, i, j, v) {
       delete res;
       str = gensub("\n(\\w+): ", "\n\n\\1\n\n", "g", str);
       j = split(str, ary, "\n\n");
       for (i = 2; i <= j; i += 2) {
         ary[ tolower(ary[i]) ] = delquote(joinspace( ary[i+1] ));
       }
       v = versions[ ary[1] ];
       res["c"] = (v == "") ? "p" : "i";
       res["C"] = (v == "") ? "purged" : "installed";
       res["d"] = ary["sdesc"];
       res["l"] = ary["ldesc"];
       res["o"] = splitget(ary["install"], 2);
       res["p"] = ary[1];
       res["r"] = ary["requires"];
       res["s"] = ary["category"];
       res["v"] = (v == "") ? "<none>" : v;
       res["V"] = ary["version"];
     }
     function format(desc,  res, ary, i, j, len, val, param, m) {
       j = split(display_format, ary, "%");
       res = ary[1];
       for (i = 2; i <= j; ++i) {
         if (ary[i] == "") {
           res = res "%" ary[++i];
         } else {
           param = gensub("^([0-9]*)(\\??)([a-zA-Z])(#?).*",
                          "\\1,\\2,\\3,\\4", "", ary[i]);
           if (param != ary[i]) {
             split(param, m, ",");
             len = (m[1] == "") ? flen[m[3]] : int(m[1]);
             val = desc[m[3]];
             s = substr(ary[i], length(param)-2);
             if (len != "") {
               if (len < length(val) && !m[2] &&
                   (m[1] != "" || !fext[m[3]] && !m[4])) {
                 # if not expandable
                 val = substr(val, 1, len);
               } else if (substr(s, 1, 1) != "\n") {
                 # if not line end
                 val = sprintf("%-*s", len, val);
               }
             }
             res = res val s;
           } else {
             res = res "%" ary[i];
           }
         }
       }
       return res;
     }
     /^[^#]/ && ('$search' ~ query) {
       parsedesc($0, desc);
       printf("%s", format(desc))
     }'
}

function find_package_files()
{
  local pkg query
  for pkg in "$@"
  do
    query="${query}|($(which "$pkg" 2>/dev/null || echo "$pkg"))"
  done
  query="${query#|}"
  (
    cd /etc/setup
    for manifest in *.lst.gz
    do
      gzip -dc "$manifest" | awk -v IGNORECASE=${nocase#0} -v query="$query" -v package="${manifest%.lst.gz}" \
        'BEGIN{RS="\n"} ("/"$0 ~ query){printf("%s: %s\n", package, "/"$0)}'
    done
  )
}

# process options

noscripts=0
noupdate=1
files=()
nocase=0
match_desc=0
display_format=
command=""
packages=()
ignore_recursive_packages=""

function process_args ()
{
  while test $# -gt 0
  do
    case "$1" in

      --mirror|-m)
        echo "$2" > /etc/setup/last-mirror
        shift ; shift
      ;;

      --cache|-c)
        cygpath -aw "$2" > /etc/setup/last-cache
        shift ; shift
      ;;

      --noscripts)
        noscripts=1
        shift
      ;;

      --noupdate)
        noupdate=1
        shift
      ;;

      --update|-u)
        noupdate=0
        shift
      ;;

      --help)
        usage
        exit 0
      ;;

      --version)
        version
        exit 0
      ;;

      --file|-f)
        if ! test "-$2-" = "--"
        then
          files=( "${files[@]}" "$2" )
          shift
        else
          echo 1>&2 No file name provided, ignoring $1
        fi
        shift
      ;;

      --ignore-case|-i)
        nocase=1
        shift
      ;;

      --no-ignore-case|-no-i)
        nocase=0
        shift
      ;;

      --match-desc|-d)
        match_desc=1
        shift
      ;;

      --display-format|-F)
        display_format="$2"
        shift ; shift
      ;;

      *)
        if test "-$command-" = "--"
        then
          command=$1
        else
          packages=( "${packages[@]}" "$1" )
        fi
        shift
      ;;

    esac
  done
}

# command methods

function aptcyg_mirrors()
{
  get_mirrors
}

function aptcyg_update()
{
  noupdate=0
  findworkspace
  getsetup
}

function aptcyg_show()
{
  echo 1>&2 The following packages are installed:
  get_installed_packages
}

function aptcyg_versions()
{
  echo 1>&2 The following packages are installed:
  get_installed_versions | awk -F= \
    '{
       len = length($1);
       mlen = (mlen < len) ? len : mlen
       rows[line][0] = $1;
       rows[line][1] = $2;
       line++;
     }
     END {
       for ( i = 0; i < line; ++i ) {
         printf "%-*s  =%s\n", mlen, rows[i][0], rows[i][1];
       }
     }'
}

function aptcyg_find()
{
  checkpackages
  findworkspace
  getsetup
  echo ""
  echo "Searching packages:"
  display_format="${display_format:-"%c %p =%v -- %d"}" \
    get_avail_packages "${packages[@]}"
}
function aptcyg_search()
{
  aptcyg_find
}

function aptcyg_describe()
{
  checkpackages
  findworkspace
  getsetup
  echo ""
  display_format="@ %p#\n%d#\\nDescription: %l#\\nCategory: %s#\\nRequires: %r#\\nVersion: %V#\\n" \
    get_avail_packages "${packages[@]}"
}
function aptcyg_info()
{
  aptcyg_describe
}

function aptcyg_packageof()
{
  checkpackages
  find_package_files "${packages[@]}"
}

function aptcyg_install()
{
  local pkg
  checkpackages
  findworkspace
  getsetup
  for pkg in "${packages[@]}"
  do
    install_package_noscripts $pkg
    run_postinstall_scripts
  done
}
function aptcyg_reinstall()
{
  aptcyg_install
}

function aptcyg_remove()
{
  local pkg
  checkpackages
  for pkg in "${packages[@]}";
  do
    remove_package $pkg
  done
}

function aptcyg_help()
{
  usage
}


# Check to see if global options are defined
if [[ ! -z "$APTCYG_OPTIONS" ]] ; then
  # If we only have one element, assume it's a string to split
  #  and parse as an array
  if [[ "${#APTCYG_OPTIONS[*]}" -eq "1" ]] ; then
    APTCYG_OPTIONS=($APTCYG_OPTIONS)
  fi
  process_args "${APTCYG_OPTIONS[@]}"
fi

process_args "$@"

if [[ ${#files} -ne 0 ]]
then
  for file in "${files[@]}"
  do
    if [[ "$file" == - ||  -f "$file" ]]
    then
      packages=( "${packages[@]}" $(cat -- "$file") )
    else
      echo 1>&2 File $file not found, skipping
    fi
  done
fi

call_command=aptcyg_${command:=help}
if [[ $(type $call_command) == "$call_command is a function"* ]] 2>/dev/null; then
  $call_command
else
  echo "invalid command: $command"
fi
